"use strict";
module.exports = (function() {
	//use bitset to speedup process (uglified)
	/* @license
	   https://github.com/lemire/FastBitSet.js
	   Licensed under the Apache License, Version 2.0 (the "License");
	   you may not use this file except in compliance with the License.
	   You may obtain a copy of the License at

	     http://www.apache.org/licenses/LICENSE-2.0

	   Unless required by applicable law or agreed to in writing, software
	   distributed under the License is distributed on an "AS IS" BASIS,
	   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   See the License for the specific language governing permissions and
	   limitations under the License.
	*/
	var BitSetHelper = {};
	(function(r) {
		function w(r) {
			this.words = [];
			if (r) {
				if (Symbol && Symbol.iterator && r[Symbol.iterator] !== undefined) {
					var s = r[Symbol.iterator]();
					var t = s.next();
					while (!t.done) {
						this.add(t.value);
						t = s.next()
					}
				} else {
					for (var o = 0; o < r.length; o++) {
						this.add(r[o])
					}
				}
			}
		}
		w.prototype.add = function(r) {
			this.resize(r);
			this.words[r >>> 5] |= 1 << r
		};
		w.prototype.flip = function(r) {
			this.resize(r);
			this.words[r >>> 5] ^= 1 << r
		};
		w.prototype.clear = function() {
			this.words = []
		};
		w.prototype.remove = function(r) {
			this.resize(r);
			this.words[r >>> 5] &= ~(1 << r)
		};
		w.prototype.isEmpty = function(r) {
			var s = this.words.length;
			for (var t = 0; t < s; t++) {
				if (this.words[t] !== 0) return false
			}
			return true
		};
		w.prototype.has = function(r) {
			return (this.words[r >>> 5] & 1 << r) !== 0
		};
		w.prototype.checkedAdd = function(r) {
			this.resize(r);
			var s = this.words[r >>> 5];
			var t = s | 1 << r;
			this.words[r >>> 5] = t;
			return (t ^ s) >>> r
		};
		w.prototype.trim = function(r) {
			var s = this.words.length;
			while (s > 0 && this.words[s - 1] === 0) {
				s--
			}
			this.words = this.words.slice(0, s)
		};
		w.prototype.resize = function(r) {
			var s = r + 32 >>> 5;
			for (var t = this.words.length; t < s; t++) this.words[t] = 0
		};
		w.prototype.hammingWeight = function(r) {
			r -= r >>> 1 & 1431655765;
			r = (r & 858993459) + (r >>> 2 & 858993459);
			return (r + (r >>> 4) & 252645135) * 16843009 >>> 24
		};
		w.prototype.hammingWeight4 = function(r, s, t, o) {
			r -= r >>> 1 & 1431655765;
			s -= s >>> 1 & 1431655765;
			t -= t >>> 1 & 1431655765;
			o -= o >>> 1 & 1431655765;
			r = (r & 858993459) + (r >>> 2 & 858993459);
			s = (s & 858993459) + (s >>> 2 & 858993459);
			t = (t & 858993459) + (t >>> 2 & 858993459);
			o = (o & 858993459) + (o >>> 2 & 858993459);
			r = r + (r >>> 4) & 252645135;
			s = s + (s >>> 4) & 252645135;
			t = t + (t >>> 4) & 252645135;
			o = o + (o >>> 4) & 252645135;
			return (r + s + t + o) * 16843009 >>> 24
		};
		w.prototype.size = function() {
			var r = 0;
			var s = this.words.length;
			var t = this.words;
			var o = 0;
			for (; o < s; o++) {
				r += this.hammingWeight(t[o])
			}
			return r
		};
		w.prototype.array = function() {
			var r = new Array(this.size());
			var s = 0 | 0;
			var t = this.words.length;
			for (var o = 0; o < t; ++o) {
				var i = this.words[o];
				while (i != 0) {
					var d = i & -i;
					r[s++] = (o << 5) + this.hammingWeight(d - 1 | 0);
					i ^= d
				}
			}
			return r
		};
		w.prototype.forEach = function(r) {
			var s = this.words.length;
			for (var t = 0; t < s; ++t) {
				var o = this.words[t];
				while (o != 0) {
					var i = o & -o;
					r((t << 5) + this.hammingWeight(i - 1 | 0));
					o ^= i
				}
			}
		};
		w.prototype.clone = function() {
			var r = Object.create(w.prototype);
			r.words = this.words.slice();
			return r
		};
		w.prototype.intersects = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			for (var t = 0 | 0; t < s; ++t) {
				if ((this.words[t] & r.words[t]) !== 0) return true
			}
			return false
		};
		w.prototype.intersection = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			for (; t + 7 < s; t += 8) {
				this.words[t] &= r.words[t];
				this.words[t + 1] &= r.words[t + 1];
				this.words[t + 2] &= r.words[t + 2];
				this.words[t + 3] &= r.words[t + 3];
				this.words[t + 4] &= r.words[t + 4];
				this.words[t + 5] &= r.words[t + 5];
				this.words[t + 6] &= r.words[t + 6];
				this.words[t + 7] &= r.words[t + 7]
			}
			for (; t < s; ++t) {
				this.words[t] &= r.words[t]
			}
			var o = this.words.length;
			for (var t = s; t < o; ++t) {
				this.words[t] = 0
			}
			return this
		};
		w.prototype.intersection_size = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			for (var o = 0 | 0; o < s; ++o) {
				t += this.hammingWeight(this.words[o] & r.words[o])
			}
			return t
		};
		w.prototype.new_intersection = function(r) {
			var s = Object.create(w.prototype);
			var t = Math.min(this.words.length, r.words.length);
			s.words = new Array(t);
			var o = t;
			var i = 0 | 0;
			for (; i + 7 < o; i += 8) {
				s.words[i] = this.words[i] & r.words[i];
				s.words[i + 1] = this.words[i + 1] & r.words[i + 1];
				s.words[i + 2] = this.words[i + 2] & r.words[i + 2];
				s.words[i + 3] = this.words[i + 3] & r.words[i + 3];
				s.words[i + 4] = this.words[i + 4] & r.words[i + 4];
				s.words[i + 5] = this.words[i + 5] & r.words[i + 5];
				s.words[i + 6] = this.words[i + 6] & r.words[i + 6];
				s.words[i + 7] = this.words[i + 7] & r.words[i + 7]
			}
			for (; i < o; ++i) {
				s.words[i] = this.words[i] & r.words[i]
			}
			return s
		};
		w.prototype.equals = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			for (var t = 0 | 0; t < s; ++t) {
				if (this.words[t] != r.words[t]) return false
			}
			if (this.words.length < r.words.length) {
				var o = r.words.length;
				for (var t = this.words.length; t < o; ++t) {
					if (r.words[t] != 0) return false
				}
			} else if (r.words.length < this.words.length) {
				var o = this.words.length;
				for (var t = r.words.length; t < o; ++t) {
					if (this.words[t] != 0) return false
				}
			}
			return true
		};
		w.prototype.difference = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			for (; t + 7 < s; t += 8) {
				this.words[t] &= ~r.words[t];
				this.words[t + 1] &= ~r.words[t + 1];
				this.words[t + 2] &= ~r.words[t + 2];
				this.words[t + 3] &= ~r.words[t + 3];
				this.words[t + 4] &= ~r.words[t + 4];
				this.words[t + 5] &= ~r.words[t + 5];
				this.words[t + 6] &= ~r.words[t + 6];
				this.words[t + 7] &= ~r.words[t + 7]
			}
			for (; t < s; ++t) {
				this.words[t] &= ~r.words[t]
			}
			return this
		};
		w.prototype.difference_size = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			var o = 0 | 0;
			for (; o < s; ++o) {
				t += this.hammingWeight(this.words[o] & ~r.words[o])
			}
			var i = this.words.length;
			for (; o < i; ++o) {
				t += this.hammingWeight(this.words[o])
			}
			return t
		};
		w.prototype.toString = function() {
			return "{" + this.array().join(",") + "}"
		};
		w.prototype.union = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			for (; t + 7 < s; t += 8) {
				this.words[t] |= r.words[t];
				this.words[t + 1] |= r.words[t + 1];
				this.words[t + 2] |= r.words[t + 2];
				this.words[t + 3] |= r.words[t + 3];
				this.words[t + 4] |= r.words[t + 4];
				this.words[t + 5] |= r.words[t + 5];
				this.words[t + 6] |= r.words[t + 6];
				this.words[t + 7] |= r.words[t + 7]
			}
			for (; t < s; ++t) {
				this.words[t] |= r.words[t]
			}
			if (this.words.length < r.words.length) {
				this.resize((r.words.length << 5) - 1);
				var o = r.words.length;
				for (var t = s; t < o; ++t) {
					this.words[t] = r.words[t]
				}
			}
			return this
		};
		w.prototype.new_union = function(r) {
			var s = Object.create(w.prototype);
			var t = Math.max(this.words.length, r.words.length);
			s.words = new Array(t);
			var o = Math.min(this.words.length, r.words.length);
			var i = 0;
			for (; i + 7 < o; i += 8) {
				s.words[i] = this.words[i] | r.words[i];
				s.words[i + 1] = this.words[i + 1] | r.words[i + 1];
				s.words[i + 2] = this.words[i + 2] | r.words[i + 2];
				s.words[i + 3] = this.words[i + 3] | r.words[i + 3];
				s.words[i + 4] = this.words[i + 4] | r.words[i + 4];
				s.words[i + 5] = this.words[i + 5] | r.words[i + 5];
				s.words[i + 6] = this.words[i + 6] | r.words[i + 6];
				s.words[i + 7] = this.words[i + 7] | r.words[i + 7]
			}
			for (; i < o; ++i) {
				s.words[i] = this.words[i] | r.words[i]
			}
			var d = this.words.length;
			for (var i = o; i < d; ++i) {
				s.words[i] = this.words[i]
			}
			var h = r.words.length;
			for (var i = o; i < h; ++i) {
				s.words[i] = r.words[i]
			}
			return s
		};
		w.prototype.new_difference = function(r) {
			return this.clone().difference(r)
		};
		w.prototype.union_size = function(r) {
			var s = Math.min(this.words.length, r.words.length);
			var t = 0 | 0;
			for (var o = 0 | 0; o < s; ++o) {
				t += this.hammingWeight(this.words[o] | r.words[o])
			}
			if (this.words.length < r.words.length) {
				var i = r.words.length;
				for (var o = this.words.length; o < i; ++o) {
					t += this.hammingWeight(r.words[o] | 0)
				}
			} else {
				var i = this.words.length;
				for (var o = r.words.length; o < i; ++o) {
					t += this.hammingWeight(this.words[o] | 0)
				}
			}
			return t
		};
		r.BitSet = w
	})(BitSetHelper);


	var make_array = function(l) {
		var ret = [];
		if (l.length == 1) {
			for (var i = 0; i < l[0]; ++i) {
				ret.push(new BitSetHelper.BitSet);
			}
		} else {
			for (var i = 0; i < l[0]; ++i) {
				ret.push(make_array(l.slice(1)));
			}
		}
		return ret;
	}


	var calc_num = function(f, hand, rest, offset, recordDeal) {
		for (var i = 1; i <= 9; ++i) {
			for (var j = 0; j < 10; ++j) {
				for (var k = 0; k < 10; ++k) {
					for (var l = 0; l < 3; ++l) {
						for (var m = 0; m < 3; ++m) {
							for (var n = 0; n < 2; ++n) {
								for (var o = -Math.min(hand[i - 1 + offset], k); o <= Math.min(rest[i - 1 + offset], j); ++o) {
									for (var r = 0; r <= n; ++r) {
										if (hand[i - 1 + offset] + o - l - m - (n - r) * 2 < 0) continue;
										var frj = j;
										var frk = k;
										var frn = hand[i - 1 + offset] + o - (n - r) * 2;
										if (o < 0) {
											frk = k + o;
										} else {
											frj = j - o;
										}
										if (f[i - 1][frj][frk][m][(frn - l - m) % 3][r].has(0)) {
											f[i][j][k][l][m][n].union(f[i - 1][frj][frk][m][(frn - l - m) % 3][r]);
											if ((o < 0 && recordDeal == 0) || (o > 0 && recordDeal == 1)) {
												f[i][j][k][l][m][n].add(i + offset);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return f;
	}

	var calc_st = function(f, hand, rest, offset, recordDeal) {
		for (var i = 1; i <= 7; ++i) {
			for (var j = 0; j < 10; ++j) {
				for (var k = 0; k < 10; ++k) {
					for (var n = 0; n < 2; ++n) {
						for (var o = -Math.min(k, hand[i - 1 + offset]); o <= Math.min(rest[i - 1 + offset], j); ++o) {
							for (var r = 0; r <= n; ++r) {
								if (hand[i - 1 + offset] + o - (n - r) * 2 < 0) continue;
								var frn = hand[i - 1 + offset] + o - (n - r) * 2;
								if (frn % 3 != 0) continue;

								var frj = j;
								var frk = k;
								if (o < 0) {
									frk = k + o;
								} else {
									frj = j - o;
								}
								if (f[i - 1][frj][frk][r].has(0)) {
									f[i][j][k][n].union(f[i - 1][frj][frk][r]);
									if ((o < 0 && recordDeal == 0) || (o > 0 && recordDeal == 1)) {
										f[i][j][k][n].add(i + offset);
									}
								}
							}
						}
					}
				}
			}
		}
		return f;
	}

	var calc_xts = function(hand, rest) {

		var needP1 = 1,
			handSum = 0;
		for (var i = 0; i < hand.length; ++i) {
			handSum += hand[i];
		}

		if (handSum == 1 || handSum == 4 || handSum == 7 || handSum == 10 || handSum == 13) needP1 = 1;
		else if (handSum == 2 || handSum == 5 || handSum == 8 || handSum == 11 || handSum == 14) needP1 = 0;
		else {
			return {
				"type": "error",
				"data": "Invalid input"
			}; // invalid
		}
		// check hand sum

		//  0~9  0~9  0~8 0~2 0~2 0~1
		// f[10] [10] [9] [3] [3] [2]
		var f = make_array([10, 10, 10, 3, 3, 2]);
		f[0][0][0][0][0][0].add(0); // set 0th bit to 1

		f = calc_num(f, hand, rest, 0, needP1); // m
		var g = make_array([10, 10, 10, 3, 3, 2]);
		for (var j = 0; j < 10; ++j) {
			for (var k = 0; k < 10; ++k) {
				for (var n = 0; n < 2; ++n) {
					g[0][j][k][0][0][n] = f[9][j][k][0][0][n];
				}
			}
		}
		g = calc_num(g, hand, rest, 9, needP1); // s
		var h = make_array([10, 10, 10, 3, 3, 2]);
		for (var j = 0; j < 10; ++j) {
			for (var k = 0; k < 10; ++k) {
				for (var n = 0; n < 2; ++n) {
					h[0][j][k][0][0][n] = g[9][j][k][0][0][n];
				}
			}
		}
		h = calc_num(h, hand, rest, 18, needP1); // p
		//   0~7  0~9 0~8 0~1
		// l [8] [10] [9] [2]
		var l = make_array([8, 10, 10, 2]);
		for (var j = 0; j < 10; ++j) {
			for (var k = 0; k < 10; ++k) {
				for (var n = 0; n < 2; ++n) {
					l[0][j][k][n] = h[9][j][k][0][0][n];
				}
			}
		}
		l = calc_st(l, hand, rest, 27, needP1);
		var xts = -1;
		for (var i = 1; i < 10; ++i) {
			if (l[7][i][i - needP1][1].has(0)) {
				xts = i - 1;
				break;
			}
		}
		if (xts == -1) return {
			"type": "error",
			"data": "Invalid input"
		};
		var ret = {},
			ans;
		if (needP1 == 0) {
			ret = {
				"xts": xts,
				"type": "discard",
				"data": []
			};

			for (var i = 0; i < 34; ++i) {
				if (l[7][xts + 1][xts + 1][1].has(i + 1)) {
					ret.data.push(i);
				}
			}
		} else {
			ret = {
				"xts": xts,
				"type": "deal",
				"data": []
			};
			for (var i = 0; i < 34; ++i) {
				if (l[7][xts + 1][xts][1].has(i + 1)) {
					ret.data.push(i);
				}
			}
		}
		return ret;
	}

	var qdz_gsws = function(hand, ret) {
		if (hand.reduce(function(sum, x) {
				return sum + x;
			}) == 13) { //门前清状态考虑七对子
			var hands = hand.slice();
			hands.unshift(0); //第一个是非0不会
			if(hands[14] == 2)
				console.log(hands);
			var qdzxts = 6 - hands.reduce(function(sum, x) {
				return sum + (x == 2 ? 1 : 0);
			}); //七对子向听数
			if (ret["xts"] >= qdzxts) {
				if (ret["xts"] > qdzxts) {
					ret["xts"] = qdzxts;
					ret["data"] = [];
				}
				var need = []; //单张牌
				var noneed = []; //三张或四张的
				var duizi = []; //正好两张
				for (var i = 0; i < hand.length; i++) {
					if (hand[i] == 1) {
						need.push(i);
					} else if (hand[i] > 2) {
						noneed.push(i);
					} else if (hand[i] == 2) {
						duizi.push(i);
					}
				}
				if (need.length == 0) { //没有单张的，说明有三张或者四张的，来任意张手牌没有的牌都是有效牌
					for (var i = 0; i < hand.length; i++)
						if (hand[i] == 0) {
							if (ret["data"].indexOf(i) == -1)
								ret["data"].push(i);
						}
				} else { //有单张的，应当判定单张的为有效牌
					for (var i = 0; i < need.length; i++)
						if (ret["data"].indexOf(need[i]) == -1)
							ret["data"].push(need[i]);
				}
			}
			var yaojiu = [0, 8, 9, 17, 18, 26, 27, 28, 29, 30, 31, 32, 33];
			var gsws = 13 - hands.reduce(function(sum, x, index) {
				return sum + ((yaojiu.indexOf(index - 1) != -1 && x > 0) ? 1 : 0);
			}); //国士无双向听数
			if (ret["xts"] >= gsws) {
				if (ret["xts"] > gsws) {
					ret["xts"] = gsws;
					ret["data"] = [];
				}
				var shisanmian = 0; //国士无双十三面是特殊情况
				for (var i = 0; i < yaojiu.length; i++) {
					if (hand[yaojiu[i]] == 1)
						shisanmian++;
					if (hand[yaojiu[i]] == 0) //没有的幺九牌为有效牌
						if (ret["data"].indexOf(yaojiu[i]) == -1)
							ret["data"].push(yaojiu[i]);
				}
				if (shisanmian == 13)
					for (var i = 0; i < yaojiu.length; i++)
						if (ret["data"].indexOf(yaojiu[i]) == -1)
							ret["data"].push(yaojiu[i]);
			}
		}
	}


	var main = function(hand, rest) {
		var ret = {
			"type": "",
			"data": [],
			"xts": -1
		};
		var xts = calc_xts(hand, rest);
		if (xts["type"] == "error") {
			ret["type"] = "error";
			ret["data"] = xts["data"];
		} else if (xts["type"] == "deal") { //待摸牌状态
			ret["xts"] = xts["xts"];
			ret["data"] = xts["data"];
			ret["type"] = "deal";
			qdz_gsws(hand, ret);
			ret["count"] = ret["data"].reduce(function(sum, x) {
				return sum + rest[x];
			}, 0);
		} else { //待出牌状态
			ret["xts"] = xts["xts"];
			ret["type"] = "discard";
			var newData = [];
			for (var i = 0; i < hand.length; ++i) {
				if(xts["data"].indexOf(i)!=-1){
					hand[i] -= 1;
					var res = calc_xts(hand, rest);
					qdz_gsws(hand, res);
					hand[i] += 1;
					if (res["xts"] < ret['xts'])
						ret["xts"] = res["xts"];
					newData.push({
						"xts": res["xts"],
						"discard": i,
						"deal": res["data"],
						"count": res["data"].reduce(function(sum, x) {
							return sum + rest[x];
						}, 0)
					});
				}else if(hand[i] > 0){
					var res = {
						"type": "",
						"data": [],
						"xts": 100
					};
					hand[i] -= 1;
					qdz_gsws(hand, res);
					hand[i] += 1;
					if (res["xts"] < ret['xts'])
						ret["xts"] = res["xts"];
					else if(res["xts"] > ret['xts'])
						continue;
					newData.push({
						"xts": res["xts"],
						"discard": i,
						"deal": res["data"],
						"count": res["data"].reduce(function(sum, x) {
							return sum + rest[x];
						}, 0)
					});
				}
			}
			var newDatas = [];
			for (var i = 0; i < newData.length; i++)
				if (newData[i]["xts"] == ret['xts'])
					newDatas.push(newData[i]);
			ret["data"] = newDatas.sort(function(a, b) {
				return b["count"] - a["count"]
			});
		}
		return ret;
	}
	return main;
})();
